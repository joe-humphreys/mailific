/**
 * Mailific SMTP Server Library
 *
 * Copyright (C) 2023 Joe Humphreys
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * JavaCC template file
 */
options
{
    static = false;
    output_directory = "../../../../../../../target/generated-sources/javacc/net/mailific/spf/parser";
}
PARSER_BEGIN(SpfPolicy)package net.mailific.spf.parser;

import java.util.ArrayList;
import net.mailific.spf.policy.*;

@SuppressWarnings("unused")
public class SpfPolicy {

    public static void main(String args []) throws ParseException, PolicySyntaxException
    {
        try {
            SpfPolicy parser = new SpfPolicy(System.in);
            Policy policy = parser.policy();
            System.out.println(policy.toString());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
PARSER_END(SpfPolicy)

SKIP: {" "}

TOKEN:
{
  < VERSION: "v=spf1" >
}

TOKEN:
{
  <  #ALPHANUM: ( < ALPHA > | < DIGIT > ) >
 |   < #ALPHA: ["a"-"z", "A"-"Z"] >
 |  < #DIGIT: ["0"-"9"] >
}

< DSPEC > TOKEN:
{
	< MACRO_LETTER: ["s", "l", "o", "d", "i", "p", "h" ,"c", "r", "t", "v"] >
}

< DSPEC > TOKEN:
{
	<  TRANSFORMERS: ( ["0"-"9"] )* ( "r" )? >
}	

< DSPEC > TOKEN:
{
	< DELIMITER: [".", "-", "+", ",", "/", "_", "="] >
}

< DSPEC > TOKEN:
{
  <  MACRO_EXPAND: ( "%{" < MACRO_LETTER > < TRANSFORMERS > ( < DELIMITER > )* "}" ) >
}

< DSPEC > TOKEN:
{
  < MACRO_LITERAL: ["!", "\"", "#", "$", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/",
                    "0"-"9",":", ";", "<", "=", ">", "?", "@", "A"-"Z","[", "\\", "]", "^",
                    "_", "`", "a"-"z","{", "|", "}", "~"] >
}

< DSPEC > TOKEN:
{
  < MACRO_STRING: ( < MACRO_EXPAND > | < MACRO_LITERAL > )* > : DEFAULT
}


/**
	Choosing to be a little easier than the BNF. Will verify appropriate range in code. 
*/

TOKEN:
{
  < CIDR_LENGTH : "/" < DIGIT > ( < DIGIT > ( < DIGIT > )? )? >
}

TOKEN:
{
  < QUALIFIER : ["-", "+", "?", "~"] >
}

TOKEN:
{
  < ALL : "all" >
}

TOKEN:
{
	< INCLUDE : "include" >
}

TOKEN:
{
  <  A : "a" >
}

TOKEN:
{
  <  MX : "mx" >
}

TOKEN:
{
  <  PTR : "ptr" >
}

TOKEN:
{
	< EXISTS : "exists" >
}


TOKEN:
{
  < IP4 : "ip4:" > : IPNET
}

TOKEN:
{
  < IP6 : "ip6:" > : IPNET
}

<IPNET> TOKEN:
{
  < QNUM : ( ["0"-"9"] | ["1"-"9"] ["0"-"9"] | "1" ["0"-"9"] ["0"-"9"]
            | "2" ["0"-"4"] ["0"-"9"] | "25" ["0"-"5"] ) >
}

<IPNET> TOKEN:
{
  < IP4_NETWORK : < QNUM > "." < QNUM > "." < QNUM > "." < QNUM > > : DEFAULT
}

TOKEN:
{
  < #I6DIG : ["0"-"9","A"-"F","a"-"f"] >
}

TOKEN:
{
  < #I6DIGS : < I6DIG > | < I6DIG > < I6DIG > | < I6DIG > < I6DIG > < I6DIG > | < I6DIG > < I6DIG > < I6DIG > < I6DIG > >
}

<IPNET> TOKEN:
{
  < IP6_NETWORK : "::" ( < IP4_NETWORK > )? | "::" < I6DIGS > ( ":" < I6DIGS > )* ( ":" < IP4_NETWORK >)?
                  | < I6DIGS > ( ":" < I6DIGS > )+ "::" ( < IP4_NETWORK > )?
                  | < I6DIGS > ( ":" < I6DIGS > )* "::" < I6DIGS > ( ":" < I6DIGS > )* ( ":" < IP4_NETWORK >)?
  > : DEFAULT
}

TOKEN:
{
        < COLON : ":" > : DSPEC
}

TOKEN:
{
  < REDIRECT : "redirect=" > : DSPEC
}

TOKEN:
{
  < EXPLANATION : "exp=" > : DSPEC
}

TOKEN:
{
  < UNKNOWN_MOD : < ALPHA > ( ["a"-"z","A"-"Z","0"-"9","-","_","."] )* "=" > : DSPEC
}


Mechanism mechanism() throws PolicySyntaxException :
{
	Token t = null;
	String dspec = null;
	String cidr = null;
}
{
  (    <  ALL >
    {
      return new All();
    }
  |
    ( < INCLUDE > < COLON > t = < MACRO_STRING >
      {
		return new Include(t.image);
      }
    )
  |
    (      < A > ( < COLON > t = < MACRO_STRING > { dspec = t.image; } )? ( t = < CIDR_LENGTH > {  cidr = t.image; } )?
      {
        return new A(dspec, cidr);
      }
    )
  |
    (      < MX > ( < COLON > t = < MACRO_STRING > { dspec = t.image; } )? ( t = < CIDR_LENGTH > {  cidr = t.image; } )?
      {
        return new MX(dspec, cidr);
      }
    )
  |
    (      < PTR > ( < COLON > t = < MACRO_STRING > { dspec = t.image; } )?
      {
        return new Ptr(dspec);
      }
    )
  |
    (      < IP4 > ( t = < IP4_NETWORK > { dspec = t.image; } )? ( t = < CIDR_LENGTH > {  cidr = t.image; } )?
      {
        return new Ip4(dspec, cidr);
      }
    )
  |
    (      < IP6 > ( t = < IP6_NETWORK > { dspec = t.image; } )? ( t = < CIDR_LENGTH > {  cidr = t.image; } )?
      {
        return new Ip6(dspec, cidr);
      }
    )
  |
    ( < EXISTS > < COLON > t = < MACRO_STRING >
      {
		return new Exists(t.image);
      }
    )
  )   
}

Directive directive() throws PolicySyntaxException :
{
  Token t = null;
  Qualifier qualifier = null;
  Mechanism mechanism = null;
}
{
  (
    t = < QUALIFIER >
	{
	  qualifier = Qualifier.fromSymbol(t.image);
	}
   )?
    mechanism = mechanism()
	{
	  return new Directive(qualifier, mechanism);	
	}
}

Modifier modifier():
{
  Token t = null;
  String name = null;
  String spec = null;
}
{
  ( < REDIRECT > t = < MACRO_STRING >
    {
      return new Redirect(t.image);
    }
  |
    ( < EXPLANATION > t = < MACRO_STRING >
      {
		return new Explanation(t.image);
      }
    )
  |
    ( t = < UNKNOWN_MOD > { name = t.image; } t = < MACRO_STRING > { spec = t.image; }
      {
		return new UnknownModifier(name, spec);
      }
    )
  )
}

public Policy policy() throws PolicySyntaxException :
{
    Token t = null;
	String version;
	Directive directive = null;
        Modifier modifier = null;
	ArrayList<Directive> directives = new ArrayList<>();
	ArrayList<Modifier> modifiers = new ArrayList<>();
  }
{
 	     t = <VERSION>
 	     { version = t.image; }
 	     (
 	       directive = directive() { directives.add(directive); }
               | modifier = modifier() { modifiers.add(modifier); }
 	     )*
 	     < EOF >
 	 {
 	   return new Policy(version, directives, modifiers);
 	 } 
}
