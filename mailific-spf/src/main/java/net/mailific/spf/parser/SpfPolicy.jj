/**
 * Mailific SMTP Server Library
 *
 * Copyright (C) 2023 Joe Humphreys
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * JavaCC template file
 */
options
{
    debug_parser = true;
    debug_token_manager = true;

    static = false;
    output_directory = "../../../../../../../target/generated-sources/javacc/net/mailific/spf/parser";
}
PARSER_BEGIN(SpfPolicy)package net.mailific.spf.parser;

import java.util.ArrayList;
import net.mailific.spf.policy.*;
import net.mailific.spf.macro.*;

@SuppressWarnings("unused")
public class SpfPolicy {

    public static void main(String args []) throws ParseException, PolicySyntaxException
    {
        try {
            SpfPolicy parser = new SpfPolicy(System.in);
            Policy policy = parser.policy();
            System.out.println(policy.toString());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
PARSER_END(SpfPolicy)

SKIP: {" "}
<DSPEC> SKIP: { " " : DEFAULT }


TOKEN:
{
    < VERSION: "v=spf1" >
}

TOKEN:
{
    <  #ALPHANUM: ( < ALPHA > | < DIGIT > ) >
        |   < #ALPHA: ["a"-"z", "A"-"Z"] >
        |  < #DIGIT: ["0"-"9"] >
        }

/**
TOKEN:
{
  < TOPLABEL: ( ( < ALPHANUM > )* < ALPHA > ( < ALPHANUM > )* )
              | ( < ALPHANUM > "-" ( < ALPHANUM > | "-" )* < ALPHANUM > ) >
}
*/

<MEX> TOKEN:
{
    < MACRO_LETTER: ["s", "l", "o", "d", "i", "p", "h" ,"c", "r", "t", "v"] > : MEX2
}

<MEX2> TOKEN:
{
    < DIGITS: ( ["0"-"9"] ) + >
}

<MEX2> TOKEN: { < REVERSE : "r" > }

<MEX2> TOKEN:
{
    < DELIMITER: ( [".", "-", "+", ",", "/", "_", "="] )+ >
}

<MEX2> TOKEN:
{
    <  MACRO_EXPAND_END: "}" > : DSPEC
}

<DSPEC> TOKEN: { < MACRO_EXPAND_START : "%{" > : MEX }


<DSPEC> TOKEN:
{
    < MACRO_LITERAL: ( ["!", "\"", "#", "$", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/",
                      "0"-"9",":", ";", "<", "=", ">", "?", "@", "A"-"Z","[", "\\", "]", "^",
                        "_", "`", "a"-"z","{", "|", "}", "~"] )+ >
        }

/**
 * TODO put macro expand back in
< DSPEC > TOKEN:
{
    < MACRO_STRING: ( < MACRO_EXPAND > | < MACRO_LITERAL > )* > : DEFAULT
        }
*/

< DSPEC > TOKEN:
{
    < MACRO_STRING: ( < MACRO_LITERAL > )* > : DEFAULT
        }




/**
   Choosing to be a little easier than the BNF. Will verify appropriate range in code. 
*/

TOKEN:
{
    < CIDR_LENGTH : "/" < DIGIT > ( < DIGIT > ( < DIGIT > )? )? >
        }

TOKEN:
{
    < QUALIFIER : ["-", "+", "?", "~"] >
        }

TOKEN:
{
    < ALL : "all" >
        }

TOKEN:
{
    < INCLUDE : "include" >
        }

TOKEN:
{
    <  A : "a" >
        }

TOKEN:
{
    <  MX : "mx" >
        }

TOKEN:
{
    <  PTR : "ptr" >
        }

TOKEN:
{
    < EXISTS : "exists" >
        }


TOKEN:
{
    < IP4 : "ip4:" > : IPNET
        }

TOKEN:
{
    < IP6 : "ip6:" > : IPNET
        }

<IPNET> TOKEN:
{
    < QNUM : ( ["0"-"9"] | ["1"-"9"] ["0"-"9"] | "1" ["0"-"9"] ["0"-"9"]
               | "2" ["0"-"4"] ["0"-"9"] | "25" ["0"-"5"] ) >
        }

<IPNET> TOKEN:
{
    < IP4_NETWORK : < QNUM > "." < QNUM > "." < QNUM > "." < QNUM > > : DEFAULT
        }

TOKEN:
{
    < #I6DIG : ["0"-"9","A"-"F","a"-"f"] >
        }

TOKEN:
{
    < #I6DIGS : < I6DIG > | < I6DIG > < I6DIG > | < I6DIG > < I6DIG > < I6DIG > | < I6DIG > < I6DIG > < I6DIG > < I6DIG > >
        }

<IPNET> TOKEN:
{
    < IP6_NETWORK : "::" ( < IP4_NETWORK > )? | "::" < I6DIGS > ( ":" < I6DIGS > )* ( ":" < IP4_NETWORK >)?
        | < I6DIGS > ( ":" < I6DIGS > )+ "::" ( < IP4_NETWORK > )?
        | < I6DIGS > ( ":" < I6DIGS > )* "::" < I6DIGS > ( ":" < I6DIGS > )* ( ":" < IP4_NETWORK >)?
        > : DEFAULT
        }

TOKEN:
{
    < COLON : ":" > : DSPEC
        }

TOKEN:
{
    < REDIRECT : "redirect=" > : DSPEC
        }

TOKEN:
{
    < EXPLANATION : "exp=" > : DSPEC
        }

TOKEN:
{
    < UNKNOWN_MOD : < ALPHA > ( ["a"-"z","A"-"Z","0"-"9","-","_","."] )* "=" > : DSPEC
        }



MacroString macroString() throws PolicySyntaxException :
{
    Token t = null;
    MacroString ms = new MacroString();
    Macro macro = null;
}
{
    (
     macro = macro()
     {
         ms.add(macro);
     }
     |
     t = < MACRO_LITERAL >
     {
         ms.add(new Literal(t.image));
     }
     /**
     |
     t = < TOPLABEL >
     {
         ms.add(new Literal(t.image));
     }
     */
     )*
    {
        return ms;
    }
}

/**
   TODO: technically, a domain-spec is a subset of macro-strings
   that end with either a domain-end or a macro expansion. It is
   a lot of work to get the grammar to enforce that, because
   domain-end is also a valid run of macro-literals. So for now
   I'm just doing the verification afterward, which is OK because
   there are no places where domainSpec is one of a choice and the
   parser might want to backtrack if it doesn't match because of
   the ending.
*/
MacroString domainSpec() throws PolicySyntaxException :
{
    MacroString ms = null;
}
{
    ms = macroString()
    {
       return ms;
    }
}


Macro macro() throws PolicySyntaxException :
{
    Token t = null;
    String type = null;
    int digits = 0;
    boolean reverse = false;
    String delimiter = null;
}
{
    ( < MACRO_EXPAND_START >
      t = <MACRO_LETTER> { type = t.image; }
      ( t = <DIGITS> { digits = Integer.parseInt(t.image); } )?
      ( <REVERSE> { reverse = true; } )?
      ( t = <DELIMITER> { delimiter = t.image; } )?
      < MACRO_EXPAND_END >
    )
    {
        return Macro.macro(type, digits, reverse, delimiter);
    }
}

Mechanism mechanism() throws PolicySyntaxException :
{
    Token t = null;
    String dspec = null;
    String cidr = null;
    MacroString ms = null;
}
{
    (    <  ALL >
     {
         return new All();
     }
     |
     ( < INCLUDE > < COLON > ms = domainSpec()
       {
           return new Include(ms);
       }
       )
     |
     (      < A > 
      {
          ms = null;
      }
      ( < COLON > ms = domainSpec() )? ( t = < CIDR_LENGTH > {  cidr = t.image; } )?
      {
          return new A(ms, cidr);
      }
      )
     |
     (      < MX > 
      {
          ms = null;
      }
      ( < COLON > ms = domainSpec() )? ( t = < CIDR_LENGTH > {  cidr = t.image; } )?
      {
          return new MX(ms, cidr);
      }
      )
     |
     (      < PTR >
      {
          ms = null;
      }
      ( < COLON > ms = domainSpec() )?
      {
          return new Ptr(ms);
      }
      )
     |
     (      < IP4 > ( t = < IP4_NETWORK > { dspec = t.image; } )? ( t = < CIDR_LENGTH > {  cidr = t.image; } )?
      {
          return new Ip4(dspec, cidr);
      }
      )
     |
     (      < IP6 > ( t = < IP6_NETWORK > { dspec = t.image; } )? ( t = < CIDR_LENGTH > {  cidr = t.image; } )?
      {
          return new Ip6(dspec, cidr);
      }
      )
     |
     ( < EXISTS > < COLON > ms = domainSpec()
       {
           return new Exists(ms);
       }
       )
     )   
        }

Directive directive() throws PolicySyntaxException :
{
    Token t = null;
    Qualifier qualifier = null;
    Mechanism mechanism = null;
}
{
    (
     t = < QUALIFIER >
     {
         qualifier = Qualifier.fromSymbol(t.image);
     }
     )?
        mechanism = mechanism()
        {
            return new Directive(qualifier, mechanism);   
        }
}

Modifier modifier():
{
    Token t = null;
    String name = null;
    String spec = null;
}
{
    ( < REDIRECT > t = < MACRO_STRING >
      {
          return new Redirect(t.image);
      }
      |
      ( < EXPLANATION > t = < MACRO_STRING >
        {
            return new Explanation(t.image);
        }
        )
      |
      ( t = < UNKNOWN_MOD > { name = t.image; } t = < MACRO_STRING > { spec = t.image; }
      {
        return new UnknownModifier(name, spec);
      }
    )
  )
}

public Policy policy() throws PolicySyntaxException :
{
    Token t = null;
    String version;
    Directive directive = null;
    Modifier modifier = null;
    ArrayList<Directive> directives = new ArrayList<>();
    ArrayList<Modifier> modifiers = new ArrayList<>();
}
{
    t = <VERSION>
         { version = t.image; }
         (
           directive = directive() { directives.add(directive); }
               | modifier = modifier() { modifiers.add(modifier); }
         )*
         < EOF >
     {
       return new Policy(version, directives, modifiers);
     } 
}
