/**
 * Mailific SMTP Server Library
 *
 * Copyright (C) 2023 Joe Humphreys
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * JavaCC template file
 */
options
{
    /**
    debug_parser = true;
    debug_lookahead = true;
    debug_token_manager = true;
    */


    static = false;
    output_directory = "../../../../../../../target/generated-sources/javacc/net/mailific/spf/parser";
}
PARSER_BEGIN(SpfPolicy)package net.mailific.spf.parser;

import java.util.ArrayList;
import net.mailific.spf.policy.*;
import net.mailific.spf.macro.*;

@SuppressWarnings("unused")
public class SpfPolicy {

    public static void main(String args []) throws ParseException, PolicySyntaxException
    {
        try {
            SpfPolicy parser = new SpfPolicy(System.in);
//            Policy policy = parser.policy();
  //          System.out.println(policy.toString());

            MacroString ms = parser.explainString();
            System.out.println(ms.toString());

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
PARSER_END(SpfPolicy)

SKIP: {" "}
<DSPEC> SKIP: { " " : DEFAULT }

TOKEN:
{
    < VERSION: "v=spf1" >
}

TOKEN:
{
    <  #ALPHANUM: ( < ALPHA > | < DIGIT > ) >
        |   < #ALPHA: ["a"-"z", "A"-"Z"] >
        |  < #DIGIT: ["0"-"9"] >
        }

/**
 * I've partially collapsed toplabel and domain-end
 */
<DSPEC> TOKEN:
{
    < TOPLABEL: ( "." ( ( ( < ALPHANUM > )* < ALPHA > ( < ALPHANUM > )* )
                        | ( < ALPHANUM > "-" ( < ALPHANUM > | "-" )* < ALPHANUM > ) ) )+
         (".")? >
}


<MEX> TOKEN:
{
    < MACRO_LETTER: ["s", "l", "o", "d", "i", "p", "h" , "v"] > : MEX2
}

<MEX2,EMEX2> TOKEN:
{
    < DIGITS: ( ["0"-"9"] ) + >
}

<MEX2,EMEX2> TOKEN: { < REVERSE : "r" > }

<MEX2,EMEX2> TOKEN:
{
    < DELIMITER: ( [".", "-", "+", ",", "/", "_", "="] )+ >
}

<MEX2> TOKEN:
{
    <  MACRO_EXPAND_END: "}" > : DSPEC
}

<DSPEC> TOKEN: { < MACRO_EXPAND_START : "%{" > : MEX }

<DSPEC,EXP> TOKEN: { < MACRO_ESCAPED : "%" ["%","_","-"] > }


<DSPEC,EXP> TOKEN:
{
    < MACRO_LITERAL: ( ["!", "\"", "#", "$", "&", "'", "(", ")", "*", "+", ",", "-", "/",
                      "0"-"9",":", ";", "<", "=", ">", "?", "@", "A"-"Z","[", "\\", "]", "^",
                        "_", "`", "a"-"z","{", "|", "}", "~"] )+ | "." >
        }



/**
   Choosing to be a little easier than the BNF. Will verify appropriate range in code. 
*/

TOKEN: { < CIDR_START : "/" > : CIDR }
<CIDR> TOKEN: { < CIDR_DIGITS : < DIGIT > ( < DIGIT > ( < DIGIT > )? )? > : DEFAULT }



TOKEN:
{
    < QUALIFIER : ["-", "+", "?", "~"] >
        }

TOKEN:
{
    < ALL : "all" >
        }

TOKEN:
{
    < INCLUDE : "include" >
        }

TOKEN:
{
    <  A : "a" >
        }

TOKEN:
{
    <  MX : "mx" >
        }

TOKEN:
{
    <  PTR : "ptr" >
        }

TOKEN:
{
    < EXISTS : "exists" >
        }


TOKEN:
{
    < IP4 : "ip4:" > : IPNET
        }

TOKEN:
{
    < IP6 : "ip6:" > : IPNET
        }

<IPNET> TOKEN:
{
    < QNUM : ( ["0"-"9"] | ["1"-"9"] ["0"-"9"] | "1" ["0"-"9"] ["0"-"9"]
               | "2" ["0"-"4"] ["0"-"9"] | "25" ["0"-"5"] ) >
        }

<IPNET> TOKEN:
{
    < IP4_NETWORK : < QNUM > "." < QNUM > "." < QNUM > "." < QNUM > > : DEFAULT
        }

TOKEN:
{
    < #I6DIG : ["0"-"9","A"-"F","a"-"f"] >
        }

TOKEN:
{
    < #I6DIGS : < I6DIG > | < I6DIG > < I6DIG > | < I6DIG > < I6DIG > < I6DIG > | < I6DIG > < I6DIG > < I6DIG > < I6DIG > >
        }

<IPNET> TOKEN:
{
    < IP6_NETWORK : "::" ( < IP4_NETWORK > )? | "::" < I6DIGS > ( ":" < I6DIGS > )* ( ":" < IP4_NETWORK >)?
        | < I6DIGS > ( ":" < I6DIGS > )+ "::" ( < IP4_NETWORK > )?
        | < I6DIGS > ( ":" < I6DIGS > )* "::" < I6DIGS > ( ":" < I6DIGS > )* ( ":" < IP4_NETWORK >)?
        > : DEFAULT
        }

TOKEN:
{
    < COLON : ":" > : DSPEC
        }

TOKEN:
{
    < REDIRECT : "redirect=" > : DSPEC
        }

TOKEN:
{
    < EXPLANATION : "exp=" > : DSPEC
        }

TOKEN:
{
    < UNKNOWN_MOD : < ALPHA > ( ["a"-"z","A"-"Z","0"-"9","-","_","."] )* "=" > : DSPEC
        }



MacroString macroString() throws PolicySyntaxException :
{
    Token t = null;
    MacroString ms = new MacroString();
    Macro macro = null;
}
{
    (
     macro = macro()
     {
         ms.add(macro);
     }
     |
     t = < MACRO_LITERAL >
     {
         ms.add(new Literal(t.image));
     }
     |
     t = < TOPLABEL >
     {
         ms.add(new Literal(t.image));
     }
     )*
    {
        return ms;
    }
}

/**
   TODO: technically, a domain-spec is a subset of macro-strings
   that end with either a domain-end or a macro expansion. It is
   a lot of work to get the grammar to enforce that, because
   domain-end is also a valid run of macro-literals. So for now
   I'm just doing the verification afterward, which is OK because
   there are no places where domainSpec is one of a choice and the
   parser might want to backtrack if it doesn't match because of
   the ending.
*/
MacroString domainSpec() throws PolicySyntaxException :
{
    Token t = null;
    MacroString ms = new MacroString();
    boolean domainEnd = false;
    Macro macro = null;
}
{
    (
     macro = macro()
     {
         domainEnd = true;
         ms.add(macro);
     }
     |
     t = < MACRO_LITERAL >
     {
         domainEnd = false;
         ms.add(new Literal(t.image));
     }
     |
     t = < TOPLABEL >
     {
         domainEnd = true;
         ms.add(new Literal(t.image));
     }
     )*
    {
        if (! domainEnd) {
            throw new PolicySyntaxException("Domain-spec can't end in macro literal.");
        }
        return ms;
    }

}


Macro macro() throws PolicySyntaxException :
{
    Token t = null;
    String type = null;
    int digits = 0;
    boolean reverse = false;
    String delimiter = null;
}
{
    (
     t = < MACRO_ESCAPED >
     {
         type = t.image.substring(1);
     }
     |
      < MACRO_EXPAND_START >
      t = <MACRO_LETTER> { type = t.image; }
      ( t = <DIGITS> { digits = Integer.parseInt(t.image); } )?
      ( <REVERSE> { reverse = true; } )?
      ( t = <DELIMITER> { delimiter = t.image; } )?
      < MACRO_EXPAND_END >
    {
        return Macro.macro(type, digits, reverse, delimiter);
    }
     |
      < E_MACRO_EXPAND_START >
      t = <E_MACRO_LETTER> { type = t.image; }
      ( t = <DIGITS> { digits = Integer.parseInt(t.image); } )?
      ( <REVERSE> { reverse = true; } )?
      ( t = <DELIMITER> { delimiter = t.image; } )?
      < E_MACRO_EXPAND_END >
    {
        return Macro.macro(type, digits, reverse, delimiter);
    }
)
}

Mechanism mechanism() throws PolicySyntaxException :
{
    Token t = null;
    String dspec = null;
    int cidr = -1;
    MacroString ms = null;
}
{
    (    <  ALL >
     {
         return new All();
     }
     |
     ( < INCLUDE > < COLON > ms = domainSpec()
       {
           return new Include(ms);
       }
       )
     |
     (      < A > 
      {
          ms = null;
      }
            ( < COLON > ms = domainSpec() )? 
            ( < CIDR_START > t = < CIDR_DIGITS > {  cidr = Integer.parseInt(t.image); } )?
      {
          return new A(ms, cidr);
      }
      )
     |
     (      < MX > 
      {
          ms = null;
      }
            ( < COLON > ms = domainSpec() )?
            ( < CIDR_START > t = < CIDR_DIGITS > {  cidr = Integer.parseInt(t.image); } )?
      {
          return new MX(ms, cidr);
      }
      )
     |
     (      < PTR >
      {
          ms = null;
      }
      ( < COLON > ms = domainSpec() )?
      {
          return new Ptr(ms);
      }
      )
     |
     (      < IP4 > ( t = < IP4_NETWORK > { dspec = t.image; } )?
            ( < CIDR_START > t = < CIDR_DIGITS > {  cidr = Integer.parseInt(t.image); } )?
      {
          return new Ip4(dspec, cidr);
      }
      )
     |
     (      < IP6 > ( t = < IP6_NETWORK > { dspec = t.image; } )?
            ( < CIDR_START > t = < CIDR_DIGITS > {  cidr = Integer.parseInt(t.image); } )?
      {
          return new Ip6(dspec, cidr);
      }
      )
     |
     ( < EXISTS > < COLON > ms = domainSpec()
       {
           return new Exists(ms);
       }
       )
     )   
        }

Directive directive() throws PolicySyntaxException :
{
    Token t = null;
    Qualifier qualifier = null;
    Mechanism mechanism = null;
}
{
    (
     t = < QUALIFIER >
     {
         qualifier = Qualifier.fromSymbol(t.image);
     }
     )?
        mechanism = mechanism()
        {
            return new Directive(qualifier, mechanism);   
        }
}

Modifier modifier() throws PolicySyntaxException :
{
    Token t = null;
    MacroString ms = null;
}
{
    ( < REDIRECT > ms = domainSpec()
      {
          return new Redirect(ms);
      }
      |
      ( < EXPLANATION > ms = domainSpec()
        {
            return new Explanation(ms);
        }
        )
      |
      ( t = < UNKNOWN_MOD >  ms = macroString()
      {
        return new UnknownModifier(t.image, ms);
      }
    )
  )
}

public Policy policy() throws PolicySyntaxException :
{
    Token t = null;
    String version;
    Directive directive = null;
    Modifier modifier = null;
    ArrayList<Directive> directives = new ArrayList<>();
    ArrayList<Modifier> modifiers = new ArrayList<>();
}
{
    t = <VERSION>
         { version = t.image; }
         (
           directive = directive() { directives.add(directive); }
               | modifier = modifier() { modifiers.add(modifier); }
         )*
         < EOF >
     {
       return new Policy(version, directives, modifiers);
     } 
}


<EXP> TOKEN : { < SP : " " > }
<EXP> TOKEN: { < E_MACRO_EXPAND_START : "%{" > : EMEX }
<EMEX> TOKEN:
{
    < E_MACRO_LETTER: ["s", "l", "o", "d", "i", "p", "h" ,"c", "r", "t", "v"] > : EMEX2
}
<EMEX2> TOKEN:
{
    <  E_MACRO_EXPAND_END: "}" > : EXP
}


public MacroString explainString() throws PolicySyntaxException:
{
    Token t = null;
    MacroString ms = new MacroString();
    Macro macro = null;
   token_source.SwitchTo(EXP);
}
{
    (
     macro = macro()
     {
         ms.add(macro);
     }
     |
     t = < MACRO_LITERAL >
     {
         ms.add(new Literal(t.image));
     }
     |
     < SP >
     {
         ms.add(new Literal(" "));
     }
     )*
    {
        return ms;
    }
}

< * > TOKEN :
{
  < UNEXPECTED_CHAR : ~[] >
}
